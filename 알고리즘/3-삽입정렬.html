<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 삽입정렬 : 어떠한 데이터를 특정 위치에 삽입
        // 삽입 정렬은 아직 정렬되지 않은 임의의 데이터를 이미 정렬된 부분의 적절한 위치에 삽입해 가며 정렬하는 방식

        // 두번째 데이터 부터 시작을 해서 맨 앞의 데이터와 비교한다.

        // [5, 3] : 1번 인덱스가 기준이 되어 앞의 0번 인덱스와 비교한다. 

        // [5, 3, 2] : 1번 인덱스와 0번 인덱스를 비교하여 [3, 5, 2] 
        // [3, 5, 2] : 2번 인덱스와 1번을 비교하여 [3, 2, 5] -> 바뀐 1번과 0번을 비교하여 [2, 3, 5]


        // [5, 3, 2, 4] : 1번기준 [3, 5, 2, 4]
        // [3, 5, 2, 4] : 2번기준 [3, 2, 5, 4] -> [2, 3, 5, 4]
        // [2, 3, 5, 4] : 3번기준 [2, 3, 4, 5]

        // 턴이 처음 일어날 떄는 기준 인덱스가 1번순으로 다음 턴에는 2번처럼 턴의 횟수만큼 기준 인덱스가 1씩 증가한다.

        console.log(sortList([5, 3, 2, 4]));

        function sortList(exList) {
            for (var stand = 0; stand < exList.length - 1; stand++) { // 턴 횟수 , 기준 인덱스
                for (var index = stand + 1; index >= 0; index--) { // 기준 인덱스와 비교할 비교 시작 인덱스를 설정하고 0이 될때까지 감소시킨다. 
                    if (exList[index] < exList[index - 1]) { // 뒤 데이터보다 앞 데이터가 클때
                        var temp = exList[index]; // 두 인덱스중 더 작은 값을 복사하고
                        exList[index] = exList[index - 1]; // 뒤 데이터에는 더 큰 값을 넣어주고
                        exList[index - 1] = temp; // 앞 데이터 에는 더 작은 값이 복사된 변수를 할당
                    } else {
                        break // 앞의 갚이 뒤의 값보다 작다면 해당 조건문을 멈추고 다음 turn을 한다.
                    }
                }
            }
            return exList
        }

        // 앞에서 부터 제일 작은 데이터 순으로 채워나가는 것은 선택정렬과 비슷하다.

    </script>
</body>

</html>